\section{Introduction}
\label{sec:introduction}

% Research context
The use of domain-specific languages (DSLs) has become a successful technique to achieve separation of concerns in the development of complex systems \cite{Cook:2006}. A DSL is a software language in which expressiveness is scoped into a well-defined domain that offers a set of abstractions (a.k.a., language constructs) needed to describe certain aspect of the system \cite{Combemale:2014}. For example, in the literature we can find DSLs for prototyping graphical user interfaces \cite{Oney:2012}, specifying security policies \cite{Lodderstedt:2002}, or performing data analysis \cite{Eberius:2012}. 

Naturally, the adoption of such language-oriented vision relies on the availability of the DSLs needed for expressing all the aspects of the system under construction. This fact carries the development of these DSLs which is a challenging task also due to the specialized knowledge it requires. A language designer must own not only quite solid modeling skills but also the technical expertise for conducting the definition of specific artifacts such as grammars, metamodels, compilers, and interpreters. As a mater of fact, the ultimate value of DSLs has been severely limited by the cost of the associated tooling (i.e., editors, parsers, etc...) \cite{jezequel:2014}.

To deal with such complexity, the research community in Software Languages Engineering (SLE) has proposed mechanisms to increase reuse during the construction of DSLs. The idea is to leverage previous engineering efforts and minimize implementation from scratch. These reuse mechanisms are based on the premise that ``software languages are software too'' \cite{Favre:2011} so it is possible to use software engineering techniques to facilitate their construction \cite{Kleppe:2009}. In particular, there are approaches that take ideas from Component-Based Software Engineering (CBSE) and Software Product Lines Engineering (SPLE) during the construction of new DSLs. Thus, ideas such as Components-Based DSLs Development\cite{Cleenewerck:2003} and Language Product Lines \cite{Zschaler:2010} have started to appear.

% Problem statement
A classical way for adopting the aforementioned reuse mechanisms is to construct DSLs as building blocks (a.k.a, language modules) that can be later extended and/or imported as part of the specifications of future DSLs. For example, there are approaches that exploit the notion of genericity in DSLs \cite{Rose:2013}, as well as approaches that support definition and composition of interdependent language modules \cite{Vacchi:2015,Mernik:2013,Rumpe:2010}. The success of this strategy relies on a set of design decisions that favor extensibility and/or genericity thus increasing the probabilities that the language modules are useful in the future. In this case, the major complexity comes from the fact that language designers do not know \textit{a priori} the needs of future DSLs. Consequently, in practice many of these building blocks are not reusable \textit{as is} and rather they require some previous adaptation.

An alternative strategy is to focus on legacy DSLs. That is, to exploit reuse in existing DSLs that have been developed independently and without being designed to be reused \cite{degueule:2015}. This strategy is quite useful when there are DSLs that share some commonalities (i.e., they provide similar language constructs) that can be encapsulated in independent language modules by means of reverse-engineering methods. This type of \textit{a posteriori} reuse permits not only to reduce maintenance cost but also to facilitate the development of new DSLs that can be built from the composition of the resulting language modules. It is worth highlighting, however, that the very first step towards the application of this strategy is to identify potential reuse. In other words, language designers need to detect sets of DSLs that share commonalities and they have to be sure that these commonalities are enough to justify the effort associated to the reverse-engineering process.

%The aforementioned reuse mechanisms can be adopted by means of two different approaches: \textit{top-down} and \textit{bottom-up}. The top-down approach proposes the design and implementation from scratch of reusable language modules that can be employed in the construction of several DSLs. Differently, the bottom-up approach proposes the use or reverse-engineering processes to extract those language modules from existing DSLs that share some commonalities which can be properly encapsulated. Whereas the major complexity in top-down approaches is that language designers should design language modules by trying to predict their potential reuse; bottom-up approaches do not have to deal with that problem. Rather, the extraction of the reusable language modules is based on the detection of commonalities in existing DSLs. Consequently, bottom-up approaches can be considered as promising approach and, indeed, there are already in the literature some works (e.g., \cite{vacchi:2014}) advancing towards that direction. 

% Contribution
In this paper, we present an approach that takes as input a set of DSLs and identifies which of them share commonalities so they have potential reuse. To do so, we perform static analysis on the artifacts where the DSLs are specified and compare language constructs at the level of the syntax and semantics in order to detect commonalities. Besides, our approach computes a set of metrics on the DSLs that permit to objectively evaluate if the existing potential reuse justifies the effort required by the reverse-engineering process. This second part of our approach is based on some reuse metrics already proposed in the literature for the general case of software development \cite{Berger:2014,Berger:126283} that we adapt them to the specific case of DSLs development.

We validate our approach by taking as input an important amount of languages available on \texttt{GitHub} public repositories. The results of this validation are quite promising since they show that there is a large amount of sets of DSLs that share language constructs and where reuse opportunities are evident. All the ideas presented in this paper are implemented in an Eclipse-based tool that can be downloaded and installed as well as the validation scenarios. 

%It is quite important to mention that our approach is inspired on the work of Berger et al X that presents the foundations for measuring product line-ability of families of software products in the general case. Our contributions with respect to that work are that we apply these ideas to the particular case of DSLs. Besides, at the best of our knowledge, there is not a tool implementing such ideas so we introduce a proposal. Finally, we apply our proposal in an empirical study performed on GitHub repositories where the objective is to identify families of DSLs in the Web and to evaluate its potential reuse. 

% Outline
This paper is organized as follows: Section \ref{sec:background} introduces a set of preliminary definitions/assumptions that we use all along the paper. Section \ref{sec:motivatingscenario} presents a motivating scenario that illustrates both the problem and the solution tacked in this paper. Section \ref{sec:puzzlemetrics} introduces the foundations of our approach. Section \ref{sec:validation} validates the approach on DSLs we take from GitHub. Section X discusses the threads to validity. Section X presents the related work and, finally, Section X concludes the paper. 

