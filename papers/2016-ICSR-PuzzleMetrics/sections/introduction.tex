\section{Introduction}
\label{sec:introduction}

% Research context
The use of domain-specific languages (DSLs) has become a successful approach to achieve separation of concerns in the development of complex systems \cite{Cook:2006}. A DSL is a software language in which expressiveness is scoped into a well-defined domain that offers the abstractions needed to describe certain aspect of the system \cite{Combemale:2014}. For example, in the literature we can find DSLs for prototyping graphical user interfaces \cite{Oney:2012}, specifying security policies \cite{Lodderstedt:2002}, or performing data analysis \cite{Eberius:2012}. 

Naturally, the adoption of such language-oriented vision relies on the availability of the DSLs needed for expressing all the aspects of the system under construction. This fact carries the development of these DSLs which is a challenging task also due to the specialized knowledge it requires. A language designer must own not only quite solid modeling skills but also the technical expertise for conducting the definition of specific artifacts such as grammars, metamodels, compilers, and interpreters. As a matter of fact, the ultimate value of DSLs has been severely limited by the cost of the associated tooling (i.e., editors, parsers, compilers, etc...) \cite{jezequel:2014}.

To deal with such complexity, the research community in Software Languages Engineering (SLE) has proposed mechanisms to increase reuse within the construction of DSLs. The idea is to leverage previous engineering efforts and minimize implementation from scratch. These reuse mechanisms are based on the premise that ``software languages are software too'' \cite{Favre:2011} so it is possible to use software engineering techniques to facilitate their construction \cite{Kleppe:2009}. In particular, there are approaches that take ideas from Component-Based Software Engineering (CBSE) and Software Product Lines Engineering (SPLE) during the construction of new DSLs \cite{Liebig:2013,Cazzola:2013b,White:2009}.

% Problem statement
The aforementioned reuse mechanisms can be adopted by means of two different approaches: \textit{top-down} and \textit{bottom-up}. The top-down approach proposes the design and implementation from scratch of reusable language modules that can be employed in the construction of several DSLs. Differently, the bottom-up approach proposes the use or reverse-engineering processes to extract those language modules from existing DSLs that share some commonalities which can be properly encapsulated. Whereas the major complexity in top-down approaches is that language designers should design language modules by trying to predict their potential reuse; bottom-up approaches do not have to deal with that problem. Rather, the extraction of the reusable language modules is based on the detection of commonalities in existing DSLs. Consequently, bottom-up approaches can be considered as promising approach and, indeed, there are already in the literature some works (e.g., \cite{vacchi:2014}) advancing towards that direction. 

% Contribution
It is worth noting that the very first step towards a reverse engineering process for DSLs is the identification of potential reuse. In other words, before applying reverse engineering, language designers need: (1) to identify sets of DSLs with potential reuse and; (2) be sure that the potential reuse is enough to justify the associated effort. In this paper, we present a proposal to automatically tackle this issue. Concretely, we introduce an approach that takes as input a set of DSLs and identifies which of them share commonalities so they have potential reuse. To do so, we perform static analysis on the artifacts where the DSLs are specified (i.e., metamodels and semantic definitions). Besides, our approach computes a set of metrics on the DSLs that permit to objectively evaluate if the potential reuse justifies the effort required by the reverse-engineering process. This second part of our approach is based on some reuse metrics already proposed in the literature for the general case of software development \cite{Berger:2014,Berger:126283} that we adapt them to the specific case of DSLs development.

We validate our approach by taking as input an important amount of languages available on GitHub public repositories. The results of this validation are quite promising. All the ideas presented in this paper are implemented in an Eclipse-based tool that can be downloaded and installed as well as the validation scenarios. 

%It is quite important to mention that our approach is inspired on the work of Berger et al X that presents the foundations for measuring product line-ability of families of software products in the general case. Our contributions with respect to that work are that we apply these ideas to the particular case of DSLs. Besides, at the best of our knowledge, there is not a tool implementing such ideas so we introduce a proposal. Finally, we apply our proposal in an empirical study performed on GitHub repositories where the objective is to identify families of DSLs in the Web and to evaluate its potential reuse. 

% Outline
This paper is organized as follows: After this introduction, Section \ref{sec:background} introduces a set of basic definitions we use along the paper. Section \ref{sec:moticatingscenario} presents a motivating scenario that illustrates both the problem and the solution tacked in this paper. Section \ref{sec:puzzlemetrics} introduces the foundations of our approach. Section \ref{sec:validation} validates the approach on DSLs we take from GitHub. Section X discusses the threads to validity. Section X presents the related work and, finally, Section X concludes the paper. 

