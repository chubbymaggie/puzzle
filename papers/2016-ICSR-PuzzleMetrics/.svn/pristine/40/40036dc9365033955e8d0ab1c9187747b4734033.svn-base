\section{Motivation}
\label{sec:problemmotivation}

Domain-specific languages (DSLs) allow domain experts the expression of solutions directly in terms of relevant domain concepts and, for example, use generative mechanisms to transform specifications of DSLs into software artifacts (e.g. code, configuration files or documentation). Thus, abstracting away from the complexity of the rest of the system and the intricacies of its implementation. As a result, the construction of DSLs is becoming a recurrent activity during the development of software intensive systems \cite{jezequel:2014}. However, the engineering of DSLs is a complex task in the context of large companies such as Thales where the users often have different --and sometimes conflicting-- requirements on the same DSL. For example, certain user may require a textual concrete syntax while another user prefers a graphical concrete syntax. Worst, for two different users, the meaning (or semantics) of a particular concept of the language may differ. When this occurs, we have a set of different DSLs that share some commonalities and that are distinguished each other by some particularities. In the literature this is known under the term of \textit{families of DSLs} \cite{Liebig:2013}.

Figure \ref{fig:state-machines} illustrates this situation by presenting a segment of the family of DSLs for modeling finite state machines deeply studied in \cite{Crane:2007} and composed of: Rhapsody \cite{Harel:2004}, Classical statecharts \cite{Harel:1996}, and UML state machines diagrams \cite{OMG:2005}. In this case, the commonalities among the three DSLs are the basic concepts of states and transitions. In turn, the differences are focused on the concepts of timed transitions and simultaneous events; while Rhapsody and UML include the notion of timed transitions, it is not supported in classical statecharts. On the other hand, classical statecharts support simultaneous events whereas both Rhapsody and UML adopt to the idea of run-to-completion i.e., each event is attended after processing the precedent one. Note that the second difference corresponds to a conflict in the semantics of the events dispatching functionality; all languages support that functionality but its semantics varies.

\begin{figure}[h!]
  \centering\includegraphics[width=120mm]{images/state-machines}
  \caption{A family of DSLs for finite state machines}
  \label{fig:state-machines}
\end{figure} 

Although the problem of dealing with families of DSLs is becoming more and more recurrent, currently there is little support for their implementation. Usually, each DSL member of the family is developed in isolation and from scratch what is not convenient because the construction of DSLs is a challenging task; to successfully perform such activity, an engineer must own not only quite solid modeling skills but also the technical expertise for conducting the definition of specific artifacts such as grammars, metamodels, compilers, and interpreters, among others. Nevertheless, as remembered by J.M. Favre in \cite{Favre:2011} \textbf{software languages are software too} and, consequently, there is room for application of software engineering techniques that facilitate their construction process (i.e., software languages engineering \cite{Kleppe:2008}). In particular, the research community has realized that the ideas behind Software Product Lines Engineering (SPLE) can be used for facilitating the construction of families of DSLs. This paper presents a PhD thesis aimed to contribute in this effort. To do so, we briefly discuss the challenges that should be addressed during the process of going from a family of DSLs to a \textit{software languages line}. Then, we discuss the state of the art, and finally we present a research plan. 

\section{Problem Statement}

We have identified three challenges towards the construction software languages lines. 

\begin{itemize}

\item \textbf{Languages modular design.} The main purpose of an approach for well-engineering families of DSLs is to increase the reuse in the sense that those language segments that are shared between two or more members of the family can be easily shared without being implemented independently and from scratch. To do so, it is necessary to separate those shared segments and encapsulate them in such a way that their specification artifacts can be actually used as part of the specification of the languages that require it. This separation implies a mechanism that allows to specify a language in different modules (a.k.a. language units) that can be later composed together to provide a complete language specification.

\vspace{3mm}

\item \textbf{Multi-dimensional variability modeling.} It is worth noting that differences and particularities among members of a family of DSLs can be found in one or several dimensions of the specification. Indeed, the work presented in \cite{Cengarle:2009} provides a classification of the possible types of variability that can be found within families of DSLs. A brief summary of this classification is introduced below; the challenge in this case is to be able to propose an approach that supports these types of variability. 

\vspace{2mm}

\begin{itemize}

\item \textit{Functional variability:} One of the motivations for implementing families of DSLs is to offer customized languages that provide only the constructs required by certain type of users. The hypothesis is that the user will adopt the language easier if the language only offers the constructs he/she actually needs. If there are additional concepts the complexity of the language (and the tools) needlessly increases and \textit{"the users are forced to rely on abstractions that might not be naturally part of the abstraction level at which they are working"} \cite{Zschaler:2010}. Functional variability refers to the capability of selecting the desired language constructs for a particular type of user. Because of the abstract syntax of the language is the base of the specification --i.e., there can not be definitions neither in the concrete syntax nor the semantics for concepts that do not exist in the abstract syntax-- the functional variability relies on the activity of selecting the subset of the abstract syntax required for a particular user. 

\vspace{2mm}

\item \textit{Syntactic variability:} Depending on the context and, again, on the type of user, the use of certain types of concrete syntax may be more appropriate than other one. Consider for example the dichotomy between textual or graphical notations. Empirical studies such as the presented in \cite{Mora:2011} show that, for a specific case, graphical notations are more appropriate than textual notations whereas other evaluation approaches argue that textual notations have advantages in cases where models become large \cite{Eichelberger:2013}. More intermediate perspectives (e.g., \cite{Heidenreich:2009}) state that graphical and textual notations more that mutually exclusive are complementary. Syntactical variability refers to the capability of supporting different representations for the same language construct. In terms of the specification, the syntactical variability can be viewed as different implementations of the concrete syntax specification unit for a given abstract syntax specification unit.

\vspace{2mm}

\item \textit{Semantic variability:} Another problem that has gained attention in the literature of software languages engineering is the semantic variation points existing in software languages. A semantic variation point appears where the same construct can have several interpretations. Consider for example the semantics differences that exist between state machines languages explored in \cite{Crane:2007}. For example, the construct \textit{fork} can be interpreted as a concurrency point where all the output transitions are dispatched simultaneously or simply as a bifurcation point where the output transitions are dispatched sequentially. Semantic variability refers to capability of supporting different interpretations to the same language construct. In terms of the specification, semantic variability can be viewed as different implementations of the semantic specification unit for a given abstract specification unit. 

\end{itemize}
	
\vspace{3mm}
	
\item \textbf{Language units composition.} After successfully modeling the variability, the next challenge is to compose a concrete DSL from a configuration of the family. In other words, after selecting the required language units, they have to interact each other for constituting a DSL that actually works. To do so, a mechanism for language unit composition is required. The main requirement on this composition mechanism is that allows to select from a set of language units the ones that should be combined. To do so, an external language that allows to express the composition is needed. In the context of software architecture that should be an architectural description language that allows to select a set of given components and compose them together. Note that this requirement is strongly related with the modularization mechanism.

\end{itemize}