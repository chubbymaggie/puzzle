\section{Introduction}
\label{sec:introduction}

% Research context
The use of domain-specific languages (DSLs) has become a successful technique to achieve separation of concerns in the development of complex systems \cite{Cook:2006}. A DSL is a software language in which expressiveness is scoped into a well-defined domain that offers a set of abstractions (a.k.a., language constructs) needed to describe certain aspect of the system \cite{Combemale:2014}. For example, in the literature we can find DSLs for prototyping graphical user interfaces \cite{Oney:2012}, specifying security policies \cite{Lodderstedt:2002}, or performing data analysis \cite{Eberius:2012}. 

Naturally, the adoption of such language-oriented vision relies on the availability of the DSLs needed for expressing all the aspects of the system under construction. Besides, typically every software project is unique and requires the construction of tailor-made DSLs for dealing with all its particular aspects \cite{Clark:2013}. This fact carries the development of many DSLs which is a challenging task due the specialized knowledge it demands. A language designer must own not only quite solid modeling skills but also the technical expertise for conducting the definition of specific artifacts such as grammars, metamodels, compilers, and interpreters. As a mater of fact, the ultimate value of DSLs has been severely limited by the cost of the associated tooling (i.e., editors, parsers, etc...) \cite{jezequel:2014}.

To improve cost-benefit when using DSLs, the research community in software languages engineering has proposed mechanisms to increase reuse during the DSLs construction process. The idea is to leverage previous engineering efforts and minimize implementation from scratch \cite{Storm:2013}. These reuse mechanisms are based on the premise that ``software languages are software too'' \cite{Favre:2011} so it is possible to use software engineering techniques to facilitate their construction \cite{Kleppe:2009}. In particular, there are approaches that take ideas from Component-Based Software Engineering (CBSE) \cite{Cleenewerck:2003} and Software Product Lines Engineering (SPLE)  \cite{Zschaler:2010} during the construction of new DSLs.

% Problem statement
A classical way for adopting the aforementioned reuse mechanisms is to construct DSLs as building blocks (a.k.a, language modules) that can be later extended and/or imported as part of the specifications of future DSLs. Indeed, there are approaches that support definition of interdependent language modules that can be later composed among them \cite{Vacchi:2015,Mernik:2013,Rumpe:2010}. However, the definition of language modules that can be useful in future DSLs is not easy. In part, this is due to the fact that, as the same as in the general case of software development processes, a language module is always designed to work in a particular context that, in general, depends on the current project. 

A more pragmatical approach to leverage reuse in the construction of DSLs is to focus on legacy DSLs \cite{degueule:2015}. That is, to exploit reuse in existing DSLs that have been developed independently and without being designed to be reused but that share some commonalities (i.e., they provide similar language constructs). Using this strategy, language modules can be extracted from the commonalities of the DSLs by means of reverse-engineering methods. This type of \textit{a posteriori} reuse permits not only to reduce maintenance cost but also to facilitate the development of new DSLs that can be built from the composition of the resulting language modules.

As the reader may guess, the very first step towards the application of this strategy is to identify potential reuse in a set of existing DSLs. Language designers need to detect commonalities between the DSLs under study and objectively evaluate whether those commonalities represent potential reuse enough to justify the effort associated to the reverse-engineering process. This first step is quite important because reverse-engineering is an expensive process. Language designers must be sure that applying it will actually improve cost-benefit. 

%The aforementioned reuse mechanisms can be adopted by means of two different approaches: \textit{top-down} and \textit{bottom-up}. The top-down approach proposes the design and implementation from scratch of reusable language modules that can be employed in the construction of several DSLs. Differently, the bottom-up approach proposes the use or reverse-engineering processes to extract those language modules from existing DSLs that share some commonalities which can be properly encapsulated. Whereas the major complexity in top-down approaches is that language designers should design language modules by trying to predict their potential reuse; bottom-up approaches do not have to deal with that problem. Rather, the extraction of the reusable language modules is based on the detection of commonalities in existing DSLs. Consequently, bottom-up approaches can be considered as promising approach and, indeed, there are already in the literature some works (e.g., \cite{vacchi:2014}) advancing towards that direction. 

%The success of this strategy relies on a set of design decisions that favor extensibility and/or genericity thus increasing the probabilities that the language modules are useful in the future. In this case, the major complexity comes from the fact that language designers do not know \textit{a priori} the needs of future DSLs. Consequently, in practice many of these building blocks are not reusable \textit{as is} and rather they require some previous adaptation.

% Contribution
In this paper, we present an approach that takes as input a set of DSLs and identifies the commonalities existing among them. To do so, we perform static analysis on the artifacts where the DSLs are specified and compare language constructs at the level of the syntax and semantics in order to detect commonalities. Besides, our approach computes a set of metrics that permit to objectively evaluate those commonalities. This second part of our approach is based on some reuse metrics already proposed in the literature for the general case of software development \cite{Berger:2014,Berger:126283} that we adapt them to the specific case of DSLs development.

We validate our approach by taking as input an important amount of languages available on \texttt{GitHub} public repositories. The results of this validation are quite promising since they show that there is a large amount of sets of DSLs that share language constructs and where reuse opportunities are evident. All the ideas presented in this paper are implemented in an Eclipse-based tool that can be downloaded and installed as well as the validation scenarios. 

%It is quite important to mention that our approach is inspired on the work of Berger et al X that presents the foundations for measuring product line-ability of families of software products in the general case. Our contributions with respect to that work are that we apply these ideas to the particular case of DSLs. Besides, at the best of our knowledge, there is not a tool implementing such ideas so we introduce a proposal. Finally, we apply our proposal in an empirical study performed on GitHub repositories where the objective is to identify families of DSLs in the Web and to evaluate its potential reuse. 

% Outline
This paper is organized as follows: Section \ref{sec:background} introduces a set of preliminary definitions/assumptions that we use all along the paper. Section \ref{sec:apprach} describes our approach. Section \ref{sec:validation} validates the approach on DSLs we take from GitHub. Section \ref{sec:threads} discusses the threads to validity. Section \ref{sec:relatedwork} presents the related work and, finally, Section \ref{sec:conclusions} concludes the paper. 

