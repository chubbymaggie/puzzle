\section{Related work}
\label{sec:relatedwork}

The idea of families of languages has already been discussed in the software engineering literature. We can find \textit{``integral approaches"} that propose an integral solution to the problem by addressing the three challenges presented above. Besides, there are \textit{``partial approaches"} that deal only with one or two of these challenges (e.g., approaches for components-based DSLs development deal with languages modular design but do not consider variability management). In this section, we briefly discuss the strengths and weaknesses of integral approaches. Partial approaches will discussed in a publication currently in progress. 

In the work presented in \cite{Cazzola:2013b} the modularization problem is treated by using Neverlang \cite{Cazzola:2012} i.e., a tool that allows the expression of a software language in separate language units that can be later composed for generating an interpreter. In turn, the variability management mechanism is addressed by using the Common Variability Language (CVL). The main advantage of that work is that there is a clear mapping between the variability modeling approach with the modularization tool. The specifically the authors present the notion of ``slices" as the mechanism for composing certain features of a language in Neverlang, then, providing support for functional and semantical variability. However, in Neverlang the abstract and the concrete syntax of language units are defined in the same artifact (i.e., a BNF-like grammar). As a result, it is not possible to support syntactical variability. Besides, there is not any support for static validation of compatibility between different language units. Hence, compatibility problems can only be detected in composition time by reading the errors produced by the composition tool. 

The work presented in \cite{Liebig:2013} introduces the concept of \textit{crosscutting modularization}, that is, the capability of decomposing a language not only into different language units but also decomposing a language feature into several tool features in order to support not only functional variability but also syntactical and semantical variability. Each tool feature represents a dimension of the language specification (e.g., syntax, semantics, constraints, documentation). The weaknesses of this approach are fundamentally the lack of static verification of composability and the lack of support for the definition of constraints in the variability model. Using this approach, the language engineer may produce invalid configurations by selecting, for example, a semantic feature that requires a non-selected abstract syntax feature. To void this, the variability model should be annotated with dependency constraints --what may produce as many constraints as existing features in the model--. We claim that this process can be facilitated by considering the definition of a staged processes where each dimension of the variability is defined in a different variability model and they are presented in order to the user in such a way that each step only includes selectable features. 

Finally, work presented in \cite{Cengarle:2009} is a formalization of the foundations for managing variability managment in software languages lines. It considers the notions of functional, semantic, and syntactic variability. Besides, the authors present a languages benchmark called MontiCore \cite{Rumpe:2010} that supports modularization of modeling languages. Although there is not a technical impediment for implementing a family of DSLs using this variability modeling mechanism in junction with MontiCore, to the best of our knowledge, there is not a concrete implementation of an approach that includes both functionalities at the same time. 