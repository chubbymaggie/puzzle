\section{Introduction}
\label{sec:introduction}

% Research context
The use of domain-specific languages (DSLs) has become a successful technique to achieve separation of concerns in the development of complex systems \cite{Cook:2006}. A DSL is a software language in which expressiveness is scoped into a well-defined domain, and that offers the abstractions (a.k.a., \textit{language constructs}) needed to describe certain aspect of the system. For example, we find DSLs to build graphical user interfaces \cite{Oney:2012}, and to specify security policies \cite{Lodderstedt:2002}.

Naturally, the adoption of such language-oriented vision relies on the availability of the DSLs needed for expressing all the aspects of the system under construction \cite{Clark:2013}. This implies the development of many DSLs which is a challenging task due the specialized knowledge it demands. \iffalse A language designer must own not only quite solid modeling skills but also the technical expertise for conducting the definition of specific artifacts such as grammars, metamodels, compilers, and interpreters.\fi  As a matter of fact, the ultimate value of DSLs has been severely limited by the cost of the associated tooling (i.e., editors, parsers, etc...) \cite{jezequel:2014}.

To improve cost-benefit when using DSLs, the research community in software languages engineering has proposed mechanisms to increase \textit{reuse} during the language development process. The idea is to leverage previous engineering efforts and minimize implementation from scratch \cite{Storm:2013}. These reuse mechanisms are based on the premise that ``software languages are software too'' \cite{Favre:2011} thus, it is possible to use software engineering techniques to facilitate their construction \cite{Kleppe:2009}. For instance, there are approaches that take ideas from Component-Based Software Engineering (CBSE) \cite{Cleenewerck:2003} and Software Product Lines Engineering (SPLE) \cite{Zschaler:2010} during the construction of new DSLs.

The basic principle underlying the aforementioned reuse mechanisms is that language constructs are grouped into interdependent \textit{language modules} that can be later integrated as part of the specification of future DSLs. Current approaches for modular development of DSLs (e.g., \cite{Mernik:2013,Rumpe:2010}) are focused on providing foundations and tooling that allow language designers to explicitly specify dependencies among language modules as well as to provide the composition operators needed during the subsequent assembly process.

% Problem statement
In practice, however, reuse is rarely achieved as a result of monolithic processes where language designers define language modules while trying to predict that they will be useful in future DSLs. Rather, the exploitation of reuse is often an iterative process where reuse opportunities are discovered, in the form of replicated functionalities, during the construction of individual DSLs. For example, many DSLs offer expression languages with simple imperative instructions (e.g., \texttt{if}, \texttt{for}), variables management, and mathematical operators. Xbase \cite{Bettini:2013} is a successful experiment that demonstrates that, using compatible tooling, such replicated functionality can be encapsulated and used in different DSLs.

The major complexity of this reuse process is that both, the identification of reuse opportunities and the extraction of the corresponding languages modules are manually-performed activities. Due the large number of language constructs within a DSL, and the dependencies among them, this process is tedious and error prone. Language designers must compare DSLs in order to identify commonalities and, then, to perform a refactoring process to extract those commonalities on separated and interdependent language modules. %This idea stands on previows research shoulders that propose similar mechanisms for software in general \cite{Caldiera:1991}.

In this paper we propose a computer-aided approach to automatically identify reuse opportunities within a given set of DSLs, and to extract reusable language modules from those commonalities. To this end, we define comparison operators that we use to detect commonalities in a given set of DSLs during a static analysis process. In turn, we use principles from set and graph theories for the extraction of the reusable language modules. Our approach considers not only the syntax of the DSLs but also their semantics.

%Language modules rarely can be reused `as-is' and without any adaptation. In this context, our research question is: \textit{How to define language modules that can be actually reusable in the construction of future DSLs?} %To answer that question language designers have to deal with several issues. For example, they have to find an appropriated level of granularity where, on one hand, language modules are fine enough so they contain small sets of constructs that are useful in several situations; on the other hand, language modules that are too small may over-complex the definition of DSLs so a good balance should be found. In addition, language designers need to find the correct combination of constructs that go well together.

The validation of our approach is threefold. First, we implement our ideas in an Eclipse-based IDE in order to demonstrate that they are feasible with current capabilities of the existing language workbenches. Second, we evaluate the \textit{correctness} of our approach by demonstrating that it can be properly applied in a real case study. In particular, we use a case study that has a direct application in the industry, and composed of three different languages for modeling state machines that share certain commonalities \cite{Crane:2007}. Third, we evaluate the \textit{relevance} of our approach. To this end, we explore public \textsc{GitHub} repositories and download about 2400 DSLs where we apply an analysis in search of potential reuse. We found that, in the 50\% of the cases, there are reuse opportunities that can be exploited with our approach. %\todo[inline]{revisar mi escritura :)}

The reminder of this paper is organized as follows: Section \ref{sec:background} introduces a set of preliminary definitions/assumptions that we use all along the paper. Section \ref{sec:motivation} presents a motivation to the problem by introducing an illustrating scenario. Section \ref{sec:apprach} describes our approach that is evaluated in Section \ref{sec:validation}. Section \ref{sec:relatedwork} presents the related work and, finally, Section \ref{sec:conclusions} concludes the paper. 

%The aforementioned reuse mechanisms can be adopted by means of two different approaches: \textit{top-down} and \textit{bottom-up}. The top-down approach proposes the design and implementation from scratch of reusable language modules that can be employed in the construction of several DSLs. Differently, the bottom-up approach proposes the use or reverse-engineering processes to extract those language modules from existing DSLs that share some commonalities which can be properly encapsulated. Whereas the major complexity in top-down approaches is that language designers should design language modules by trying to predict their potential reuse; bottom-up approaches do not have to deal with that problem. Rather, the extraction of the reusable language modules is based on the detection of commonalities in existing DSLs. Consequently, bottom-up approaches can be considered as promising approach and, indeed, there are already in the literature some works (e.g., \cite{vacchi:2014}) advancing towards that direction. 

%The success of this strategy relies on a set of design decisions that favor extensibility and/or genericity thus increasing the probabilities that the language modules are useful in the future. In this case, the major complexity comes from the fact that language designers do not know \textit{a priori} the needs of future DSLs. Consequently, in practice many of these building blocks are not reusable \textit{as is} and rather they require some previous adaptation.

% Contribution


%It is quite important to mention that our approach is inspired on the work of Berger et al X that presents the foundations for measuring product line-ability of families of software products in the general case. Our contributions with respect to that work are that we apply these ideas to the particular case of DSLs. Besides, at the best of our knowledge, there is not a tool implementing such ideas so we introduce a proposal. Finally, we apply our proposal in an empirical study performed on GitHub repositories where the objective is to identify families of DSLs in the Web and to evaluate its potential reuse. 

% Outline


%Despite such important advances, the definition of language modules that can be actually useful in future DSLs is still a difficult task. In part, this difficulty is due to the fact that the reuse of a language module implies the reuse of all its constructs and language designers do not always have the information that allow them to predict the correct combination of constructs that go well together. What is the correct level of granularity? Are there constructs that should be always together? Are there constructs that should be always separated?