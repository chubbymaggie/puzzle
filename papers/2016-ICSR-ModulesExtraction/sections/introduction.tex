\section{Introduction}
\label{sec:introduction}

% Research context
The use of domain-specific languages (DSLs) has become a successful technique to achieve separation of concerns in the development of complex systems \cite{Cook:2006}. A DSL is a software language in which expressiveness is scoped into a well-defined domain that offers a set of abstractions (a.k.a., language constructs) needed to describe certain aspect of the system \cite{Combemale:2014}. For example, in the literature we can find DSLs for prototyping graphical user interfaces \cite{Oney:2012}, specifying security policies \cite{Lodderstedt:2002}, or performing data analysis \cite{Eberius:2012}. 

Naturally, the adoption of such language-oriented vision relies on the availability of the DSLs needed for expressing all the aspects of the system under construction \cite{Clark:2013}. This fact carries the development of many DSLs which is a challenging task due the specialized knowledge it demands. A language designer must own not only quite solid modeling skills but also the technical expertise for conducting the definition of specific artifacts such as grammars, metamodels, compilers, and interpreters. As a mater of fact, the ultimate value of DSLs has been severely limited by the cost of the associated tooling (i.e., editors, parsers, etc...) \cite{jezequel:2014}.

To improve cost-benefit when using DSLs, the research community in software languages engineering has proposed mechanisms to increase reuse during the construction of DSLs. The idea is to leverage previous engineering efforts and minimize implementation from scratch \cite{Storm:2013}. These reuse mechanisms are based on the premise that ``software languages are software too'' \cite{Favre:2011} so it is possible to use software engineering techniques to facilitate their construction \cite{Kleppe:2009}. In particular, there are approaches that take ideas from Component-Based Software Engineering (CBSE) \cite{Cleenewerck:2003} and Software Product Lines Engineering (SPLE)  \cite{Zschaler:2010} during the construction of new DSLs.

% Problem statement
A classical way for adopting the aforementioned reuse mechanisms is to group language constructs into interdependent \textit{language modules} that can be later extended and/or imported as part of the specifications of future DSLs. This type of solution has ultimately gained momentum and, nowadays, there are a diversity of approaches that facilitate such modular DSLs design \cite{Vacchi:2015,Mernik:2013,Rumpe:2010}. However, the definition of language modules that can be actually useful in future DSLs is not easy. In part, this is due to the fact that the reuse of a language module implies the reuse of all the constructs it offers and language designers do not always have the information that allow them to predict the correct combination of constructs that go well together. What is the correct level of granularity? Are there constructs that should be always together? Are there constructs that should be always separated?

In this paper we propose an approach to leverage reuse during the construction of DSLs focused on legacy DSLs. In other words, we propose to exploit reuse in existing DSLs that are were not necessarily built for being reused but that share some commonalities (i.e., they provide similar language constructs). In particular, we present an strategy to identify groups of constructs that are frequently used together in a given sets of legacy DSLs. Then, a catalog of language modules is extracted from the commonalities by means of a reverse-engineering method. To do so, we perform static analysis on the artifacts where the DSLs are specified and compare language constructs at the level of the syntax and semantics.

As a validation for our approach, we apply it in two different evaluation scenarios. The former, corresponds to a controled scenario composed of a set of DSLs that we built so we know what is the potential reuse so it is a kind of oracle for our approach. The second evaluation scenario corresponds to a set of DSLs we obtain from GitHub public repositories. This scenario allow us to see the performance of our approach in more realistic DSLs. 

This paper is organized as follows: Section \ref{sec:background} introduces a set of preliminary definitions/assumptions as well as some motivating examples that we use all along the paper. Section \ref{sec:apprach} describes our approach that is evaluated in Section \ref{sec:validation}. Section \ref{sec:threads} discusses the threads to validity. Section \ref{sec:relatedwork} presents the related work and, finally, Section \ref{sec:conclusions} concludes the paper. 

%The aforementioned reuse mechanisms can be adopted by means of two different approaches: \textit{top-down} and \textit{bottom-up}. The top-down approach proposes the design and implementation from scratch of reusable language modules that can be employed in the construction of several DSLs. Differently, the bottom-up approach proposes the use or reverse-engineering processes to extract those language modules from existing DSLs that share some commonalities which can be properly encapsulated. Whereas the major complexity in top-down approaches is that language designers should design language modules by trying to predict their potential reuse; bottom-up approaches do not have to deal with that problem. Rather, the extraction of the reusable language modules is based on the detection of commonalities in existing DSLs. Consequently, bottom-up approaches can be considered as promising approach and, indeed, there are already in the literature some works (e.g., \cite{vacchi:2014}) advancing towards that direction. 

%The success of this strategy relies on a set of design decisions that favor extensibility and/or genericity thus increasing the probabilities that the language modules are useful in the future. In this case, the major complexity comes from the fact that language designers do not know \textit{a priori} the needs of future DSLs. Consequently, in practice many of these building blocks are not reusable \textit{as is} and rather they require some previous adaptation.

% Contribution


%It is quite important to mention that our approach is inspired on the work of Berger et al X that presents the foundations for measuring product line-ability of families of software products in the general case. Our contributions with respect to that work are that we apply these ideas to the particular case of DSLs. Besides, at the best of our knowledge, there is not a tool implementing such ideas so we introduce a proposal. Finally, we apply our proposal in an empirical study performed on GitHub repositories where the objective is to identify families of DSLs in the Web and to evaluate its potential reuse. 

% Outline


