\section{Introduction}
\label{sec:introduction}

% Research context
The use of domain-specific languages (DSLs) has become a successful technique to achieve separation of concerns in the development of complex systems \cite{Cook:2006}. A DSL is a software language in which expressiveness is scoped into a well-defined domain that offers a set of abstractions (a.k.a., language constructs) needed to describe certain aspect of the system \cite{Combemale:2014}. For example, in the literature we can find DSLs for prototyping graphical user interfaces \cite{Oney:2012}, specifying security policies \cite{Lodderstedt:2002}, or performing data analysis \cite{Eberius:2012}.

Naturally, the adoption of such language-oriented vision relies on the availability of the DSLs needed for expressing all the aspects of the system under construction \cite{Clark:2013}. This fact carries the development of many DSLs which is a challenging task due the specialized knowledge it demands. A language designer must own not only quite solid modeling skills but also the technical expertise for conducting the definition of specific artifacts such as grammars, metamodels, compilers, and interpreters. As a matter of fact, the ultimate value of DSLs has been severely limited by the cost of the associated tooling (i.e., editors, parsers, etc...) \cite{jezequel:2014}.

To improve cost-benefit when using DSLs, the research community in software languages engineering has proposed mechanisms to increase reuse during the construction of DSLs. The idea is to leverage previous engineering efforts and minimize implementation from scratch \cite{Storm:2013}. These reuse mechanisms are based on the premise that ``software languages are software too'' \cite{Favre:2011} so it is possible to use software engineering techniques to facilitate their construction \cite{Kleppe:2009}. For instance, there are approaches that take ideas from Component-Based Software Engineering (CBSE) \cite{Cleenewerck:2003} and Software Product Lines Engineering (SPLE) \cite{Zschaler:2010} during the construction of new DSLs.

The basic principle underlying the aforementioned reuse mechanisms is that language constructs are grouped into interdependent \textit{language modules} that can be later integrated as part of the specification of future DSLs. Current approaches for modular development of DSLs (e.g., \cite{Vacchi:2015,Mernik:2013,Rumpe:2010}) are focused on providing foundations and tooling that allow language designers to explicitly specify dependencies among language modules as well as to provide the composition operators needed during the subsequent assembly process.

% Problem statement
In practice, however, reuse is rarely achieved as a result of monolithic processes where language designers define language modules while trying to predict that they will be useful in future DSLs. Rather, the exploitation of reuse is often an iterative process where reuse opportunities are discovered during the construction of individual DSLs in the form of replicated functionalities that could be extracted as reusable language modules. For example, many DSLs offer expression languages with simple imperative instructions (e.g., \texttt{if}, \texttt{for}), variables management, and mathematical operators. Xbase \cite{Bettini:2013} is a successful experiment that demonstrate that, using compatible tooling, such replicated functionality can be  encapsulated and used in different DSLs.

The major complexity of this reuse process is that both, the identification of reuse opportunities and the extraction of the corresponding languages modules are manually-performed activities. Due the large number of language constructs within a DSL and the dependencies among them, this process is tedious and error prone. Language designers have to compare DSLs in order to identify commonalities and, then, to perform a refactoring process to extract those commonalities on separated and interdependent language modules. 

Inspired in the work of Caldiera and Basili \cite{Caldiera:1991}, in this paper we propose a computer-aided mechanism that automatically identifies reuse opportunities within a given set of DSLs. Then, reusable language modules are extracted from those commonalities while establishing the corresponding dependencies. Our proposal relies on the static analysis that includes not only the syntax of the DSLs but also their semantics. 

%Language modules rarely can be reused `as-is' and without any adaptation. In this context, our research question is: \textit{How to define language modules that can be actually reusable in the construction of future DSLs?} %To answer that question language designers have to deal with several issues. For example, they have to find an appropriated level of granularity where, on one hand, language modules are fine enough so they contain small sets of constructs that are useful in several situations; on the other hand, language modules that are too small may over-complex the definition of DSLs so a good balance should be found. In addition, language designers need to find the correct combination of constructs that go well together.

We validate our approach in two scenarios. On the first hand we apply this solution and its tooling support in a project involving three industrial partners. Later, for the sake of generality, we applied our solution to realistic DSLs that we obtained from public \textsc{GitHub} repositories fitting our technological space. In both cases, we discovered more than XXX code that can be potentially modularized for the sake of reuse. 

%In this paper we propose an approach to leverage reuse during the construction of DSLs focused on legacy DSLs. In other words, we propose to exploit reuse in existing DSLs that are were not necessarily built for being reused but that share some commonalities (i.e., they provide similar language constructs). In particular, we present an strategy to identify groups of constructs that are frequently used together in a given sets of legacy DSLs. Then, a catalog of language modules is extracted from the commonalities by means of a reverse-engineering method. To do so, we perform static analysis on the artifacts where the DSLs are specified and compare language constructs at the level of the syntax and semantics.

The reminder of this paper is organized as follows: Section \ref{sec:background} introduces a set of preliminary definitions/assumptions as well as an illustrating scenario that we use all along the paper. Section \ref{sec:apprach} describes our approach that is evaluated in Section \ref{sec:validation}. Section \ref{sec:relatedwork} presents the related work and, finally, Section \ref{sec:conclusions} concludes the paper. 

%The aforementioned reuse mechanisms can be adopted by means of two different approaches: \textit{top-down} and \textit{bottom-up}. The top-down approach proposes the design and implementation from scratch of reusable language modules that can be employed in the construction of several DSLs. Differently, the bottom-up approach proposes the use or reverse-engineering processes to extract those language modules from existing DSLs that share some commonalities which can be properly encapsulated. Whereas the major complexity in top-down approaches is that language designers should design language modules by trying to predict their potential reuse; bottom-up approaches do not have to deal with that problem. Rather, the extraction of the reusable language modules is based on the detection of commonalities in existing DSLs. Consequently, bottom-up approaches can be considered as promising approach and, indeed, there are already in the literature some works (e.g., \cite{vacchi:2014}) advancing towards that direction. 

%The success of this strategy relies on a set of design decisions that favor extensibility and/or genericity thus increasing the probabilities that the language modules are useful in the future. In this case, the major complexity comes from the fact that language designers do not know \textit{a priori} the needs of future DSLs. Consequently, in practice many of these building blocks are not reusable \textit{as is} and rather they require some previous adaptation.

% Contribution


%It is quite important to mention that our approach is inspired on the work of Berger et al X that presents the foundations for measuring product line-ability of families of software products in the general case. Our contributions with respect to that work are that we apply these ideas to the particular case of DSLs. Besides, at the best of our knowledge, there is not a tool implementing such ideas so we introduce a proposal. Finally, we apply our proposal in an empirical study performed on GitHub repositories where the objective is to identify families of DSLs in the Web and to evaluate its potential reuse. 

% Outline


%Despite such important advances, the definition of language modules that can be actually useful in future DSLs is still a difficult task. In part, this difficulty is due to the fact that the reuse of a language module implies the reuse of all its constructs and language designers do not always have the information that allow them to predict the correct combination of constructs that go well together. What is the correct level of granularity? Are there constructs that should be always together? Are there constructs that should be always separated?