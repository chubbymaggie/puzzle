/*
 * generated by Xtext
 */
package fr.inria.diverse.puzzle.adl.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import fr.inria.diverse.puzzle.adl.language.AggregationConnector;
import fr.inria.diverse.puzzle.adl.language.CompositeLanguage;
import fr.inria.diverse.puzzle.adl.language.LanguagePackage;
import fr.inria.diverse.puzzle.adl.language.PuzzleComposition;
import fr.inria.diverse.puzzle.adl.services.LanguageGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == LanguagePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case LanguagePackage.AGGREGATION_CONNECTOR:
				sequence_AggregationConnector(context, (AggregationConnector) semanticObject); 
				return; 
			case LanguagePackage.COMPOSITE_LANGUAGE:
				sequence_CompositeLanguage(context, (CompositeLanguage) semanticObject); 
				return; 
			case LanguagePackage.PUZZLE_COMPOSITION:
				sequence_PuzzleComposition(context, (PuzzleComposition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=ID right=ID)
	 */
	protected void sequence_AggregationConnector(EObject context, AggregationConnector semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LanguagePackage.Literals.AGGREGATION_CONNECTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LanguagePackage.Literals.AGGREGATION_CONNECTOR__LEFT));
			if(transientValues.isValueTransient(semanticObject, LanguagePackage.Literals.AGGREGATION_CONNECTOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LanguagePackage.Literals.AGGREGATION_CONNECTOR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAggregationConnectorAccess().getLeftIDTerminalRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAggregationConnectorAccess().getRightIDTerminalRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (links+=Connector links+=Connector*)?)
	 */
	protected void sequence_CompositeLanguage(EObject context, CompositeLanguage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (melangeFile=STRING (composites+=CompositeLanguage composites+=CompositeLanguage*)?)
	 */
	protected void sequence_PuzzleComposition(EObject context, PuzzleComposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
