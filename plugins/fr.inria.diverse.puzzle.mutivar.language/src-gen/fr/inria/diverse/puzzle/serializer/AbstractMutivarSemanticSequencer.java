/*
 * generated by Xtext
 */
package fr.inria.diverse.puzzle.serializer;

import Multivar.AlternativeGroup;
import Multivar.LanguageFeature;
import Multivar.LanguageProductLine;
import Multivar.LanguageVariability;
import Multivar.MandatoryChild;
import Multivar.MultivarPackage;
import Multivar.OptionalChild;
import Multivar.OrGroupChild;
import Multivar.ProductLineVariability;
import Multivar.VariabilityPoint;
import Multivar.Variation;
import com.google.inject.Inject;
import com.google.inject.Provider;
import fr.inria.diverse.puzzle.services.MutivarGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractMutivarSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MutivarGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == MultivarPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case MultivarPackage.ALTERNATIVE_GROUP:
				sequence_AlternativeGroup(context, (AlternativeGroup) semanticObject); 
				return; 
			case MultivarPackage.LANGUAGE_FEATURE:
				sequence_LanguageFeature(context, (LanguageFeature) semanticObject); 
				return; 
			case MultivarPackage.LANGUAGE_PRODUCT_LINE:
				sequence_LanguageProductLine(context, (LanguageProductLine) semanticObject); 
				return; 
			case MultivarPackage.LANGUAGE_VARIABILITY:
				sequence_LanguageVariability(context, (LanguageVariability) semanticObject); 
				return; 
			case MultivarPackage.MANDATORY_CHILD:
				sequence_MandatoryChild(context, (MandatoryChild) semanticObject); 
				return; 
			case MultivarPackage.OPTIONAL_CHILD:
				sequence_OptionalChild(context, (OptionalChild) semanticObject); 
				return; 
			case MultivarPackage.OR_GROUP_CHILD:
				sequence_OrGroupChild(context, (OrGroupChild) semanticObject); 
				return; 
			case MultivarPackage.PRODUCT_LINE_VARIABILITY:
				sequence_ProductLineVariability(context, (ProductLineVariability) semanticObject); 
				return; 
			case MultivarPackage.VARIABILITY_POINT:
				sequence_VariabilityPoint(context, (VariabilityPoint) semanticObject); 
				return; 
			case MultivarPackage.VARIATION:
				sequence_Variation(context, (Variation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (features+=[LanguageFeature|EString] features+=[LanguageFeature|EString]*)
	 */
	protected void sequence_AlternativeGroup(EObject context, AlternativeGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         name=EString 
	 *         (depends+=[LanguageFeature|EString] depends+=[LanguageFeature|EString]*)? 
	 *         (excludes+=[LanguageFeature|EString] excludes+=[LanguageFeature|EString]*)? 
	 *         module=EString? 
	 *         (children+=Relation children+=Relation*)?
	 *     )
	 */
	protected void sequence_LanguageFeature(EObject context, LanguageFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (implementationFile=EString? productLineVariability=ProductLineVariability? languageVariability=LanguageVariability?)
	 */
	protected void sequence_LanguageProductLine(EObject context, LanguageProductLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((variabilityPoints+=VariabilityPoint variabilityPoints+=VariabilityPoint*)?)
	 */
	protected void sequence_LanguageVariability(EObject context, LanguageVariability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     feature=[LanguageFeature|EString]
	 */
	protected void sequence_MandatoryChild(EObject context, MandatoryChild semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MultivarPackage.Literals.MANDATORY_CHILD__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MultivarPackage.Literals.MANDATORY_CHILD__FEATURE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMandatoryChildAccess().getFeatureLanguageFeatureEStringParserRuleCall_1_0_1(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     feature=[LanguageFeature|EString]
	 */
	protected void sequence_OptionalChild(EObject context, OptionalChild semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MultivarPackage.Literals.OPTIONAL_CHILD__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MultivarPackage.Literals.OPTIONAL_CHILD__FEATURE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOptionalChildAccess().getFeatureLanguageFeatureEStringParserRuleCall_1_0_1(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (features+=[LanguageFeature|EString] features+=[LanguageFeature|EString]*)
	 */
	protected void sequence_OrGroupChild(EObject context, OrGroupChild semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (features+=LanguageFeature features+=LanguageFeature* rootFeature=[LanguageFeature|EString])
	 */
	protected void sequence_ProductLineVariability(EObject context, ProductLineVariability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (involvedFeatures+=[LanguageFeature|EString] involvedFeatures+=[LanguageFeature|EString]*)? 
	 *         variations+=Variation 
	 *         variations+=Variation*
	 *     )
	 */
	protected void sequence_VariabilityPoint(EObject context, VariabilityPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (default?='default'? name=EString module=EString?)
	 */
	protected void sequence_Variation(EObject context, Variation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
