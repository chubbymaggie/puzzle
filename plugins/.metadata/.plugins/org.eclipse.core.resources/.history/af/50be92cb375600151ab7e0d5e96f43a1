package fr.inria.diverse.ksynthesis.ksynthesis.facade;

import java.io.File;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

import fr.familiar.interpreter.FMLShell;
import fr.familiar.variable.FeatureModelVariable;
import fr.inria.familiar.fmlero.fmprimitives.FeatureModel;
import gsd.graph.ImplicationGraph;
import gsd.synthesis.Expression;
import gsd.synthesis.ExpressionType;
import gsd.synthesis.FeatureEdge;
import gsd.synthesis.FeatureGraph;

/**
 * Facade to the KSynthesis variability synthesizer. 
 * 
 * @author Guillaume Becan
 * @author David Mendez-Acuna
 *
 */
public class KSynthesisSynthesizer {

	// ----------------------------------------------------------
	// Attributes
	// ----------------------------------------------------------
	
	private static KSynthesisSynthesizer instance;
	
	private Random random;
	
	// ----------------------------------------------------------
	// Constructor and singleton
	// ----------------------------------------------------------
	
	private KSynthesisSynthesizer(){
		random = new Random();
	}
	
	public static KSynthesisSynthesizer getInstance(){
		if(instance == null)
			instance = new KSynthesisSynthesizer();
		return instance;
	}
	
	// ----------------------------------------------------------
	// Methods
	// ----------------------------------------------------------

	/**
	 * Synthesizes a feature model from a PCM. 
	 * @param inputFile The location of the file containing the PCM in a comma separated file
	 * @param outputFile The location of the file in which the feature model should be saved. 
	 */
	public void synthesizeFeatureModelFromPCM(String inputFile, String outputFile){
		FeatureModelVariable fm = loadPCM(inputFile);
		System.out.println(fm);
		
		
		this.clearFM(fm);
		int nbAddedConstraints = constraintGenerator.generateConstraints(fm, CONSTRAINT_PER_FEATURE * (fm.features().size() -1), PERCENTAGE_IMPLIES);
		constraintGenerator.saveFM(fm, OUTPUT_FOLDER);
		System.out.println(nbAddedConstraints + " added constraints");
		
	}
	
	public FeatureModelVariable loadPCM(String inputFile){
		FMLShell _shell = FMLShell.instantiateStandalone(null);
		File file = new File(inputFile);
		String fmIdentifier = file.getName();;
		FeatureModelVariable fm = null;

		fmIdentifier = fmIdentifier.substring(0, fmIdentifier.lastIndexOf("."));
		String command = "fm = FM(" + "A: F1 F2 F3;" + ")";
		try {
			fm = (FeatureModelVariable) _shell.parse(command);	
			
			Expression<String> constraint = new Expression<String>(ExpressionType.AND, "F1", "F2");
			fm.addConstraint(constraint);
			
		} catch (Exception e) {
			e.printStackTrace();
			fm = null;
		}
		
		return fm;
	}
	
	/**
	 * Generate constraints and save the new FM
	 * @param percentageImplies 
	 * @param maxConstraints : maximal number of constraint added
	 * @param fms
	 * @return number of added constraints
	 */
	public int generateConstraints(FeatureModelVariable fm, int maxConstraints, double percentageImplies) {

		ImplicationGraph<String> big = fm.computeImplicationGraph();
		Set<Expression<String>> excludesEdges = fm.computeExcludesEdge();

		int nbAddedConstraints = 0;

		for (int i = 0; i < maxConstraints ; i++) {
			boolean addedConstraint = false;
			for (int nbTry = 0; nbTry<10 && !addedConstraint; nbTry++) {
				if (random.nextDouble() < percentageImplies) {
					addedConstraint = addImpliesConstraint(fm, big);	
				} else {
					addedConstraint = addExcludesConstraint(fm, excludesEdges);	
				}
			}
			if (addedConstraint) {
				nbAddedConstraints++;
			}
		}
		
		return nbAddedConstraints;
	}
	
	/**
	 * Remove all the constraints and keep only the hierarchy with optional features
	 * @param fm
	 * @return 
	 */
	public void clearFM(FeatureModelVariable fm) {
		fm.removeAllConstraints();
		
		FeatureGraph<String> diagram = fm.getFm().getDiagram();
		for (FeatureEdge edge : new HashSet<FeatureEdge>(diagram.edges())) {
			if (edge.getType() != FeatureEdge.HIERARCHY) {
				diagram.removeEdge(edge);
			}
		}
	}
}
