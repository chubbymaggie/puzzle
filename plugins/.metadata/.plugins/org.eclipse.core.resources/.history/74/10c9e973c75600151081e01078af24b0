package fr.inria.diverse.ksynthesis.ksynthesis.facade;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import foreverse.ksynthesis.Heuristic;
import foreverse.ksynthesis.InteractiveFMSynthesizer;
import foreverse.ksynthesis.metrics.AlwaysZeroMetric;
import fr.familiar.interpreter.FMLShell;
import fr.familiar.variable.FeatureModelVariable;
import fr.inria.diverse.ksynthesis.ksynthesis.vos.Feature;
import fr.inria.diverse.ksynthesis.ksynthesis.vos.Product;
import fr.inria.diverse.ksynthesis.ksynthesis.vos.ProductLine;
import gsd.graph.ImplicationGraph;
import gsd.graph.SimpleEdge;
import gsd.synthesis.Expression;
import gsd.synthesis.ExpressionType;
import gsd.synthesis.FeatureEdge;
import gsd.synthesis.FeatureGraph;

/**
 * Facade to the KSynthesis variability synthesizer. 
 * 
 * @author Guillaume Becan
 * @author David Mendez-Acuna
 *
 */
public class KSynthesisSynthesizer {

	// ----------------------------------------------------------
	// Constants
	// ----------------------------------------------------------
	
	final int CONSTRAINT_PER_FEATURE = 1;
	
	final double PERCENTAGE_IMPLIES = 0.8;
	
	// ----------------------------------------------------------
	// Attributes
	// ----------------------------------------------------------
	
	private static KSynthesisSynthesizer instance;
	
	private Random random;
	
	// ----------------------------------------------------------
	// Constructor and singleton
	// ----------------------------------------------------------
	
	private KSynthesisSynthesizer(){
		random = new Random();
	}
	
	public static KSynthesisSynthesizer getInstance(){
		if(instance == null)
			instance = new KSynthesisSynthesizer();
		return instance;
	}
	
	// ----------------------------------------------------------
	// Methods
	// ----------------------------------------------------------

	/**
	 * Synthesizes a feature model from a PCM. 
	 * @param inputFile The location of the file containing the PCM in a comma separated file
	 * @param outputFile The location of the file in which the feature model should be saved. 
	 * @throws FileNotFoundException 
	 */
	public void synthesizeFeatureModelFromPCM(String inputFile, String outputFile) throws Exception{
		ProductLine pl = loadProductLineFromPCM(inputFile);
		FeatureModelVariable fm = obtainVariabilityModelConstraints(pl);
		System.out.println(fm + " base fm");
		
		InteractiveFMSynthesizer synthesizer = new InteractiveFMSynthesizer(fm, new AlwaysZeroMetric(), new ArrayList<Heuristic>(), new AlwaysZeroMetric(), -1);
		synthesizer.setRoot("A");
		FeatureModelVariable synthesizedFM = synthesizer.computeCompleteFeatureModel();
		System.out.println(synthesizedFM + " synthesized fm");
		System.out.println("synthesizedFM.getAllConstraints(): " + synthesizedFM.getAllConstraints());
	}
	
	/**
	 * Loads a ProductLineVO from the PCM in the file in the parameter.
	 * @param inputFile Location of the file that contains the PCM in a comma separated matrix. 
	 * @return
	 * @throws Exception
	 */
	private ProductLine loadProductLineFromPCM(String inputFile) throws Exception {
		ProductLine pl = new ProductLine();
		BufferedReader br = new BufferedReader(new FileReader(inputFile));
		String currentLine = br.readLine();
		String[] header = currentLine.split(",");
		
		for (int i = 1; i < header.length; i++) {
			Feature feature = new Feature(header[i]);
			pl.getFeatures().add(feature);
		}
		currentLine = br.readLine();
		
		while(currentLine != null){
			String[] productDescription = currentLine.split(",");
			Product product = new Product(productDescription[0]);
			
			for (int i = 1; i < productDescription.length; i++) {
				String currentFeature = productDescription[i];
				if(currentFeature.equals("YES")){
					product.getFeatures().add(pl.getFeatures().get(i - 1));
				}
			}
			// Loop advance
			currentLine = br.readLine();
		}
		br.close();
		
		return pl;
	}

	/**
	 * Returns a FeatureModelVariable object with the constraints encoded in the product line in the parameter. 
	 * @param pl Product line from the constraints will be computed. 
	 * @return
	 */
	public FeatureModelVariable obtainVariabilityModelConstraints(ProductLine pl){
		FMLShell _shell = FMLShell.instantiateStandalone(null);
		String command = "fm = FM(" + "root: ";
		
		for (Feature feature : pl.getFeatures()) {
			command += "[" + feature.getIdentifier() + "]";
		}
		command += "; )";
		
		FeatureModelVariable fm = (FeatureModelVariable) _shell.parse(command);	
		
		for (int i = 0; i < pl.getProducts().size(); i++) {
			Product product = pl.getProducts().get(i);
			List<Expression<String>> productConstraints = new ArrayList<Expression<String>>();
			
			for (int j = 1; j < product.getFeatures().size(); j++) {
				Feature productFeatureLeft = product.getFeatures().get(j-1);
				Feature productFeatureRight = product.getFeatures().get(j);
				Expression<String> constraint = new Expression<String>(ExpressionType.AND, "F1", "F2");
			}
			
			
		}
		
		
		Expression<String> constraintB = new Expression<String>(ExpressionType.AND, "F1", "F3");
		Expression<String> constraintC = new Expression<String>(ExpressionType.AND, "F2", "F3");
		
		Expression<String> AorB = new Expression<String>(ExpressionType.OR, constraintA, constraintB);
		Expression<String> AorBorC = new Expression<String>(ExpressionType.OR, AorB, constraintC);
//			SATFormula formula = new SATFMLFormula(AorB);
//			FeatureModelVariable fm1 = new FeatureModelVariableWithSynchronizedFormula("myXX", 
//					new gsd.synthesis.FeatureModel<String>(FeatureGraphFactory.mkStringFactory().mkTop()),
//					formula);
		fm.addConstraint(AorB);
		
		return fm;
		
		
		
	}
	
	/**
	 * Generate constraints and save the new FM
	 * @param percentageImplies 
	 * @param maxConstraints : maximal number of constraint added
	 * @param fms
	 * @return number of added constraints
	 */
	public int generateConstraints(FeatureModelVariable fm, int maxConstraints, double percentageImplies) {

		ImplicationGraph<String> big = fm.computeImplicationGraph();
		Set<Expression<String>> excludesEdges = fm.computeExcludesEdge();

		int nbAddedConstraints = 0;

		for (int i = 0; i < maxConstraints ; i++) {
			boolean addedConstraint = false;
			for (int nbTry = 0; nbTry<10 && !addedConstraint; nbTry++) {
				if (random.nextDouble() < percentageImplies) {
					addedConstraint = addImpliesConstraint(fm, big);	
				} else {
					addedConstraint = addExcludesConstraint(fm, excludesEdges);	
				}
			}
			if (addedConstraint) {
				nbAddedConstraints++;
			}
		}
		
		return nbAddedConstraints;
	}
	
	/**
	 * Remove all the constraints and keep only the hierarchy with optional features
	 * @param fm
	 * @return 
	 */
	public void clearFM(FeatureModelVariable fm) {
		fm.removeAllConstraints();
		
		FeatureGraph<String> diagram = fm.getFm().getDiagram();
		for (FeatureEdge edge : new HashSet<FeatureEdge>(diagram.edges())) {
			if (edge.getType() != FeatureEdge.HIERARCHY) {
				diagram.removeEdge(edge);
			}
		}
	}
	
	/**
	 * Try to add an "implies" constraint
	 * @param fm
	 * @param big
	 * @return the constraint was successfully added
	 */
	private boolean addImpliesConstraint(FeatureModelVariable fm, ImplicationGraph<String> big) {
		List<String> leftFeatures = new ArrayList<String>(fm.getFm().features());
		List<String> rightFeatures = new ArrayList<String>(fm.getFm().features());

		String feature1 = null;
		String feature2 = null;

		// Find a pair of features that are not in an "implies" relation
		while (!leftFeatures.isEmpty() && feature2 == null) {
			// Select feature1
			feature1 = leftFeatures.get(random.nextInt(leftFeatures.size()));

			// Select feature2 among the features that are not implied by feature1
			rightFeatures = new ArrayList<String>(fm.getFm().features());
			rightFeatures.remove(feature1);
			for (SimpleEdge implied : big.outgoingEdges(feature1)) {
				rightFeatures.remove(big.getTarget(implied));
			}

			if (!rightFeatures.isEmpty()) {
				feature2 = rightFeatures.get(random.nextInt(rightFeatures.size()));
			} else {
				leftFeatures.remove(feature1);
			}
		}

		if (feature2 == null) {
			return false;
		}

		// Add a constraint
		Expression<String> exp1 = new Expression<String>(feature1);
		Expression<String> exp2 = new Expression<String>(feature2);

		Expression<String> constraint = new Expression<String>(ExpressionType.IMPLIES, exp1, exp2);
		fm.addConstraint(constraint);

		// Check that the constraint does not produce dead features
		if (!fm.deads().isEmpty()) {
			fm.removeConstraint(constraint);
			return false;
		} else {
			big.addEdge(feature1, feature2);
			return true;
		}

	}

	/**
	 * Try to add an "excludes" constraint
	 * @param fm
	 * @param excludesEdges
	 * @return the constraint was successfully added
	 */
	private boolean addExcludesConstraint(FeatureModelVariable fm, Set<Expression<String>> excludesEdges) {
		List<String> leftFeatures = new ArrayList<String>(fm.getFm().features());
		List<String> rightFeatures = new ArrayList<String>(fm.getFm().features());

		String feature1 = null;
		String feature2 = null;

		// Find a pair of features that are not in an "excludes" relation
		while (!leftFeatures.isEmpty() && feature2 == null) {
			// Select feature1
			feature1 = leftFeatures.get(random.nextInt(leftFeatures.size()));

			// Select feature2 among the features that are not excluded by feature1
			rightFeatures = new ArrayList<String>(fm.getFm().features());
			rightFeatures.remove(feature1);
			for (Expression<String> excluded : excludesEdges) {
				String left = excluded.getLeft().getFeature();
				String right = excluded.getRight().getLeft().getFeature();
				if (feature1.equals(left)) {
					rightFeatures.remove(right);	
				} else if (feature1.equals(right)) {
					rightFeatures.remove(left);
				}

			}

			if (!rightFeatures.isEmpty()) {
				feature2 = rightFeatures.get(random.nextInt(rightFeatures.size()));
			} else {
				leftFeatures.remove(feature1);
			}
		}

		if (feature2 == null) {
			return false;
		}

		// Add a constraint
		Expression<String> exp1 = new Expression<String>(feature1);
		Expression<String> exp2 = new Expression<String>(feature2);

		Expression<String> constraint = new Expression<String>(ExpressionType.IMPLIES, exp1, exp2.not());
		fm.addConstraint(constraint);

		// Check that the constraint does not produce dead features
		if (!fm.deads().isEmpty()) {
			fm.removeConstraint(constraint);
			return false;
		} else {
			excludesEdges.add(constraint);
			return true;
		}
	}
}