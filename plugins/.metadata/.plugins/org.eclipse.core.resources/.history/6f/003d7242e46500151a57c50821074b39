package fr.inria.diverse.graph;

import java.util.ArrayList;
import java.util.List;

/**
 * Class that implements the services of a dependencies graph.
 * @author David Mendez-Acuna
 *
 */
public class Graph {

	// -----------------------------------------------
	// Attributes
	// -----------------------------------------------
	
	private List<Vertex> vertex;
	private List<Arc> arcs;

	// -----------------------------------------------
	// Constructors
	// -----------------------------------------------
	
	/**
	 * Constructor by default.
	 */
	public Graph(){
		vertex = new ArrayList<Vertex>();
		arcs = new ArrayList<Arc>();
	}
	
	// -----------------------------------------------
	// Methods
	// -----------------------------------------------
	
	/**
	 * Indicates if the origin depends on the destination.
	 * In other words, returns true if there is at least one eClassifier in the origin that contains a reference to
	 * a classifier in the destination.
	 * 
	 * @param origin
	 * @param destination
	 * @return
	 */
	private boolean dependsOn(Vertex origin, Vertex destination, EcoreGraph modularizationGraph){
		for (EcoreArc ecoreArc : modularizationGraph.getArcs()) {
			boolean fromInTheOrigin = exists(origin.getInternalVertex(), ecoreArc.getFrom());
			boolean toInTheDestination = exists(destination.getInternalVertex(), ecoreArc.getTo());
			
			if(fromInTheOrigin && toInTheDestination)
				return true;
		}
		return false;
	}
	
	
	/**
	 * Returns true of the ecore vertex is contained in the ecore vertex list. 
	 * @param internalVertex
	 * @param modularizationGraph
	 * @return
	 */
	private boolean exists(List<EcoreVertex> internalVertex, EcoreVertex vertex) {
		for (EcoreVertex ecoreVertex : internalVertex) {
			if(ecoreVertex.getVertexId().equals(vertex.getVertexId()))
				return true;
		}
		return false;
	}

	/**
	 * Indicates if there is an arc between the origin and the destination given in the parameters. 
	 * @param origin
	 * @param destination
	 * @return
	 */
	public boolean thereIsArc(Vertex origin, Vertex destination){
		for (Arc dependencyArc : arcs) {
			if(dependencyArc.getFrom().getIdentifier().equals(origin.getIdentifier()) &&
					dependencyArc.getTo().getIdentifier().equals(destination.getIdentifier()))
				return true;
		}
		return false;
	}
	
	/**
	 * Indicates if there is a path from the origin to the destination.
	 * @param origin
	 * @param destination
	 * @return
	 */
	public boolean thereIsPath(Vertex origin, Vertex destination){
		this.resetVisited();
		return origin.thereIsPath(destination);
	}
	
	/**
	 * Puts all the visited flag in false for all the vertex in the graph.
	 */
	public void resetVisited(){
		for (Vertex vertex : this.vertex) {
			vertex.setVisited(false);
		}
	}
	
	/**
	 * Indicates if there is any loop in the graph. 
	 * @return
	 */
	public boolean thereIsLoop(){
		for (Vertex vertex : this.vertex) {
			boolean loop = this.thereIsPath(vertex, vertex);
			if(loop)
				return true;
		}
		return false;
	}
	
	/**
	 * Returns the list of vertex in the graph such that they have not outgoing arcs.
	 * @return
	 */
	public List<Vertex> getIndendependentVertex(){
		List<Vertex> independentVertex = new ArrayList<Vertex>();
		for (Vertex dependencyVertex : this.vertex) {
			if(dependencyVertex.getOutgoingArcs().size() == 0)
				independentVertex.add(dependencyVertex);
		}
		return independentVertex;
	}
	
	/**
	 * Indicates if the flag 'included' is true for all the vertex in the graph.
	 * @return
	 */
	public boolean allIncluded() {
		for (Vertex currentVertex : this.vertex) {
			if(!currentVertex.isIncluded())
				return false;
		}
		return true;
	}
	
	/**
	 * Returns the list of vertex that directly depend on at least one vertex in the list in the parameter.
	 * @param currentLevel
	 * @return
	 */
	public List<Vertex> getDirectDependentVertex(
			List<Vertex> vertexList) {
		List<Vertex> directDependentVertex = new ArrayList<Vertex>();
		
		for (int i = 0; i < this.vertex.size(); i++) {
			Vertex originalVertex = this.vertex.get(i);
			for (int j = 0; j < vertexList.size(); j++) {
				Vertex inputVertex = vertexList.get(j);
				if(this.thereIsArc(originalVertex, inputVertex)){
					if(!directDependentVertex.contains(originalVertex)){
						directDependentVertex.add(originalVertex);
					}
				}
			}
		}
		return directDependentVertex;
	}
	
	public String toString(){
		String answer = "Vertex {\n";
		for (Vertex dependencyVertex : vertex) {
			answer += " - " + dependencyVertex.getIdentifier() + "\n";
		}
		answer += "}\n\n";
		answer += "Arcs (" + this.arcs.size() + ") {\n";
		for (Arc dependencyArc : arcs) {
			answer += "  + " + dependencyArc.toString() + "\n";
		}
		answer += "}\n\n";
		return answer;
	}
	
	/**
	 * Returns the arc between the origin and the destination.
	 * Returns null if there is not an arc between the given nodes. 
	 * @param origin
	 * @param destination
	 * @return
	 */
	public Arc getArc(Vertex origin,
			Vertex destination) {
		for (Arc dependencyArc : arcs) {
			if(dependencyArc.getFrom().getIdentifier().equals(origin.getIdentifier()) &&
					dependencyArc.getTo().getIdentifier().equals(destination.getIdentifier()))
				return dependencyArc;
		}
		return null;
	}
	
	// -----------------------------------------------
	// Getters
	// -----------------------------------------------
	
	public List<Vertex> getVertex() {
		return vertex;
	}

	public List<Arc> getArcs() {
		return arcs;
	}
}