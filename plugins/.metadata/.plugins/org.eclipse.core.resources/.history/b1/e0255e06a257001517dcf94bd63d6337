package fr.inria.diverse.puzzle.metrics.specialCharts;

import java.util.ArrayList;

import fr.inria.diverse.k3.sle.common.commands.ConceptComparison;
import fr.inria.diverse.k3.sle.common.graphs.DependencyGraph;
import fr.inria.diverse.k3.sle.common.graphs.DependencyVertex;
import fr.inria.diverse.k3.sle.common.graphs.EcoreArc;
import fr.inria.diverse.k3.sle.common.graphs.EcoreGraph;
import fr.inria.diverse.k3.sle.common.graphs.EcoreVertex;
import fr.inria.diverse.k3.sle.common.graphsOperators.MembershipGraphPartition;
import fr.inria.diverse.k3.sle.common.tuples.TupleConceptMember;
import fr.inria.diverse.k3.sle.common.tuples.TupleConceptMembers;
import fr.inria.diverse.k3.sle.common.tuples.TupleMembersConcepts;
import fr.inria.diverse.k3.sle.common.utils.FamiliesServices;
import fr.inria.diverse.melange.metamodel.melange.Language;

/**
 * Prints the family membership graph.
 * @author David Mendez-Acuna
 *
 */
public class ExternalDependenciesGraph implements SpecialProductLineSyntacticChart{

	// ------------------------------------------------------
	// Methods
	// ------------------------------------------------------
	
	@Override
	public String getVariablesDeclaration(ArrayList<Language> languages, 
			ConceptComparison conceptComparisonOperator,
			EcoreGraph modularizationGraph,
			DependencyGraph dependenciesGraph) throws Exception{
		
		String answer = "";
		ArrayList<TupleConceptMember> conceptMemberList = FamiliesServices.getInstance().getConceptMemberMappingList(languages);
		ArrayList<TupleConceptMembers> conceptMembersList = FamiliesServices.getInstance().getConceptMemberGroupList(conceptMemberList, conceptComparisonOperator);
		ArrayList<TupleMembersConcepts> membersConceptList = FamiliesServices.getInstance().getMembersGroupVsConceptVOList(conceptMembersList);
		
		answer += "var G = new jsnx.DiGraph();\n";
		
		String nodes = "";
		boolean first = true;
		for (DependencyVertex currentVertex : dependenciesGraph.getVertex()) {
			if(!first)
				nodes += ",";
			nodes += "\"" + currentVertex.getIdentifier() + "\"";
			first = false;
		}
		answer += "G.addNodesFrom([" + nodes + "], {group: 0 });\n";
			
		answer += "\n";
		if(dependenciesGraph.getArcs().size() > 0){
			answer += "G.addEdgesFrom([";
			
			boolean first = true;
			for (EcoreArc arc : dependenciesGraph.getArcs()) {
				if(!first) answer += ",";
				answer += "[\"" + arc.getFrom().getVertexId() + "\",\""+ arc.getTo().getVertexId() +"\"]";
				first = false;
			}
			answer += "]);\n";
		}
		return answer;
	}
}