package fr.inria.diverse.k3.sle.common.comparisonOperators;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EReference;

public class DeepConceptComparison implements ConceptComparison {

	@Override
	public boolean equals(EClassifier left, EClassifier right) {
		if(left instanceof EClass && right instanceof EClass)
			return this.compareEClasses((EClass) left, (EClass) right);
		else if(left instanceof EEnum && right instanceof EEnum)
			return this.compareEEnums((EEnum) left, (EEnum) right);
		else
			return false;
	}

	private boolean compareEClasses(EClass left, EClass right) {
		if(!left.getName().equals(right.getName()))
			return false;
		
		if(left.getEReferences().size() != right.getEReferences().size())
			return false;
		
		for (EReference eReference : left.getEReferences()) {
			if(!existsEReference(right, eReference))
				return false;
		}
		
		if(left.getEAttributes().size() != right.getEAttributes().size())
			return false;
		
		
		return true;
	}

	private boolean existsEReference(EClass eClass, EReference eReference){
		for (EReference current : eClass.getEReferences()) {
			if(compareEReferences(current, eReference))
				return true;
		}
		return false;
	}
	
	private boolean compareEReferences(EReference left, EReference right) {
		boolean identicalNames = left.getName().equals(right.getName());
		boolean identicalTypes = left.getEType().getName().equals(right.getEType().getName());
		boolean identicalLowerBounds = left.getLowerBound() == right.getLowerBound();
		boolean identicalUperBounds = left.getUpperBound() == right.getUpperBound();
		boolean identicalContainment = left.isContainment() == right.isContainment();
		
		return identicalNames && identicalTypes && identicalLowerBounds && identicalUperBounds && identicalContainment;
	}

	private boolean compareEEnums(EEnum left, EEnum right) {
		// TODO Auto-generated method stub
		return false;
	}
}
