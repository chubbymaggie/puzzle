package fr.inria.diverse.k3.sle.common.graphs;

import java.util.ArrayList;
import java.util.List;

/**
 * Class that implements the services of a dependencies graph.
 * @author David Mendez-Acuna
 *
 */
public class DependencyGraph {

	// -----------------------------------------------
	// Attributes
	// -----------------------------------------------
	
	private List<Vertex> vertex;
	private List<DependencyArc> arcs;

	// -----------------------------------------------
	// Constructors
	// -----------------------------------------------
	
	/**
	 * Constructor by default.
	 */
	public DependencyGraph(){
		vertex = new ArrayList<Vertex>();
		arcs = new ArrayList<DependencyArc>();
	}
	
	/**
	 * Builds a dependency graph from a modularization graph.
	 * @param modularizationGraph. Modularization graph that will be used to create the dependencies graph.
	 */
	public DependencyGraph(EcoreGraph modularizationGraph){
		vertex = new ArrayList<Vertex>();
		arcs = new ArrayList<DependencyArc>();
		
		// Create one vertex for each modularization group. 
		for (ArrayList<EcoreVertex> group : modularizationGraph.getGroups()) {
			String moduleName = EcoreGraph.getLanguageModuleName(group);
			Vertex dependencyVertex = new Vertex(moduleName);
			dependencyVertex.getInternalVertex().addAll(group);
			this.vertex.add(dependencyVertex);
		}
		
		// Create one arc for each dependency.
		for (int i = 0; i < vertex.size(); i++) {
			Vertex vertexI = vertex.get(i);
			for (int j = 0; j < vertex.size(); j++) {
				if(i!=j){
					Vertex vertexJ = vertex.get(j);
					if(this.dependsOn(vertexI, vertexJ, modularizationGraph)){
						DependencyArc arc = new DependencyArc(vertexI, vertexJ);
						vertexI.getOutgoingArcs().add(arc);
						vertexJ.getIncomingArcs().add(arc);
						this.arcs.add(arc);
					}
				}
			}
		}
	}
	
	// -----------------------------------------------
	// Methods
	// -----------------------------------------------
	
	/**
	 * Indicates if the origin depends on the destination.
	 * In other words, returns true if there is at least one eClassifier in the origin that contains a reference to
	 * a classifier in the destination.
	 * 
	 * @param origin
	 * @param destination
	 * @return
	 */
	private boolean dependsOn(Vertex origin, Vertex destination, EcoreGraph modularizationGraph){
		for (EcoreArc ecoreArc : modularizationGraph.getArcs()) {
			boolean fromInTheOrigin = exists(origin.getInternalVertex(), ecoreArc.getFrom());
			boolean toInTheDestination = exists(destination.getInternalVertex(), ecoreArc.getTo());
			
			if(fromInTheOrigin && toInTheDestination)
				return true;
		}
		return false;
	}
	
	
	/**
	 * Returns true of the ecore vertex is contained in the ecore vertex list. 
	 * @param internalVertex
	 * @param modularizationGraph
	 * @return
	 */
	private boolean exists(List<EcoreVertex> internalVertex, EcoreVertex vertex) {
		for (EcoreVertex ecoreVertex : internalVertex) {
			if(ecoreVertex.getVertexId().equals(vertex.getVertexId()))
				return true;
		}
		return false;
	}

	/**
	 * Indicates if there is an arc between the origin and the destination given in the parameters. 
	 * @param origin
	 * @param destination
	 * @return
	 */
	public boolean thereIsArc(Vertex origin, Vertex destination){
		for (DependencyArc dependencyArc : arcs) {
			if(dependencyArc.getFrom().getIdentifier().equals(origin.getIdentifier()) &&
					dependencyArc.getTo().getIdentifier().equals(destination.getIdentifier()))
				return true;
		}
		return false;
	}
	
	/**
	 * Indicates if there is a path from the origin to the destination.
	 * @param origin
	 * @param destination
	 * @return
	 */
	public boolean thereIsPath(Vertex origin, Vertex destination){
		this.resetVisited();
		return origin.thereIsPath(destination);
	}
	
	/**
	 * Puts all the visited flag in false for all the vertex in the graph.
	 */
	public void resetVisited(){
		for (Vertex vertex : this.vertex) {
			vertex.setVisited(false);
		}
	}
	
	/**
	 * Indicates if there is any loop in the graph. 
	 * @return
	 */
	public boolean thereIsLoop(){
		for (Vertex vertex : this.vertex) {
			boolean loop = this.thereIsPath(vertex, vertex);
			if(loop)
				return true;
		}
		return false;
	}
	
	/**
	 * Returns the list of vertex in the graph such that they have not outgoing arcs.
	 * @return
	 */
	public List<Vertex> getIndendependentVertex(){
		List<Vertex> independentVertex = new ArrayList<Vertex>();
		for (Vertex dependencyVertex : this.vertex) {
			if(dependencyVertex.getOutgoingArcs().size() == 0)
				independentVertex.add(dependencyVertex);
		}
		return independentVertex;
	}
	
	/**
	 * Indicates if the flag 'included' is true for all the vertex in the graph.
	 * @return
	 */
	public boolean allIncluded() {
		for (Vertex currentVertex : this.vertex) {
			if(!currentVertex.isIncluded())
				return false;
		}
		return true;
	}
	
	/**
	 * Returns the list of vertex that directly depend on at least one vertex in the list in the parameter.
	 * @param currentLevel
	 * @return
	 */
	public List<Vertex> getDirectDependentVertex(
			List<Vertex> vertexList) {
		List<Vertex> directDependentVertex = new ArrayList<Vertex>();
		
		for (int i = 0; i < this.vertex.size(); i++) {
			Vertex originalVertex = this.vertex.get(i);
			for (int j = 0; j < vertexList.size(); j++) {
				Vertex inputVertex = vertexList.get(j);
				if(this.thereIsArc(originalVertex, inputVertex)){
					if(!directDependentVertex.contains(originalVertex)){
						directDependentVertex.add(originalVertex);
					}
				}
			}
		}
		return directDependentVertex;
	}
	
	public String toString(){
		String answer = "Vertex {\n";
		for (Vertex dependencyVertex : vertex) {
			answer += " - " + dependencyVertex.getIdentifier() + "\n";
		}
		answer += "}\n\n";
		answer += "Arcs (" + this.arcs.size() + ") {\n";
		for (DependencyArc dependencyArc : arcs) {
			answer += "  + " + dependencyArc.toString() + "\n";
		}
		answer += "}\n\n";
		return answer;
	}
	
	/**
	 * Returns the arc between the origin and the destination.
	 * Returns null if there is not an arc between the given nodes. 
	 * @param origin
	 * @param destination
	 * @return
	 */
	public DependencyArc getArc(Vertex origin,
			Vertex destination) {
		for (DependencyArc dependencyArc : arcs) {
			if(dependencyArc.getFrom().getIdentifier().equals(origin.getIdentifier()) &&
					dependencyArc.getTo().getIdentifier().equals(destination.getIdentifier()))
				return dependencyArc;
		}
		return null;
	}
	
	// -----------------------------------------------
	// Getters
	// -----------------------------------------------
	
	public List<Vertex> getVertex() {
		return vertex;
	}

	public List<DependencyArc> getArcs() {
		return arcs;
	}
}