package fr.inria.diverse.melange.ui.builder;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.google.inject.Provider;
import fr.inria.diverse.melange.ast.LanguageExtensions;
import fr.inria.diverse.melange.ast.MetamodelExtensions;
import fr.inria.diverse.melange.ast.ModelTypeExtensions;
import fr.inria.diverse.melange.ast.ModelingElementExtensions;
import fr.inria.diverse.melange.eclipse.EclipseProjectHelper;
import fr.inria.diverse.melange.lib.EcoreExtensions;
import fr.inria.diverse.melange.metamodel.melange.Element;
import fr.inria.diverse.melange.metamodel.melange.Language;
import fr.inria.diverse.melange.metamodel.melange.Metamodel;
import fr.inria.diverse.melange.metamodel.melange.ModelType;
import fr.inria.diverse.melange.metamodel.melange.ModelTypingSpace;
import fr.inria.diverse.melange.processors.ExtensionPointProcessor;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.apache.log4j.Logger;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.core.runtime.jobs.IJobManager;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.emf.codegen.ecore.genmodel.GenModel;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.builder.EclipseResourceFileSystemAccess2;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.generator.OutputConfiguration;
import org.eclipse.xtext.generator.OutputConfigurationProvider;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ObjectExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

@SuppressWarnings("all")
public class MelangeBuilder {
  @Inject
  private IGenerator generator;
  
  @Inject
  private Provider<EclipseResourceFileSystemAccess2> fileSystemAccessProvider;
  
  @Inject
  private OutputConfigurationProvider outputProvider;
  
  @Inject
  private EclipseProjectHelper eclipseHelper;
  
  @Inject
  private ExtensionPointProcessor extensionProcessor;
  
  @Inject
  @Extension
  private LanguageExtensions _languageExtensions;
  
  @Inject
  @Extension
  private MetamodelExtensions _metamodelExtensions;
  
  @Inject
  @Extension
  private ModelingElementExtensions _modelingElementExtensions;
  
  @Inject
  @Extension
  private ModelTypeExtensions _modelTypeExtensions;
  
  @Inject
  @Extension
  private EcoreExtensions _ecoreExtensions;
  
  private final static Logger log = Logger.getLogger(MelangeBuilder.class);
  
  public void generateAll(final Resource res, final IProject project, final IProgressMonitor monitor) {
    SubProgressMonitor _subProgressMonitor = new SubProgressMonitor(monitor, 1);
    this.cleanAll(res, project, _subProgressMonitor);
    SubProgressMonitor _subProgressMonitor_1 = new SubProgressMonitor(monitor, 1);
    this.generateInterfaces(res, project, _subProgressMonitor_1);
    SubProgressMonitor _subProgressMonitor_2 = new SubProgressMonitor(monitor, 1);
    this.generateLanguages(res, project, _subProgressMonitor_2);
    SubProgressMonitor _subProgressMonitor_3 = new SubProgressMonitor(monitor, 1);
    this.generateAdapters(res, project, _subProgressMonitor_3);
    SubProgressMonitor _subProgressMonitor_4 = new SubProgressMonitor(monitor, 1);
    this.generatePluginXml(res, project, _subProgressMonitor_4);
  }
  
  public void generateInterfaces(final Resource res, final IProject project, final IProgressMonitor monitor) {
    EList<EObject> _contents = res.getContents();
    EObject _head = IterableExtensions.<EObject>head(_contents);
    final ModelTypingSpace root = ((ModelTypingSpace) _head);
    EList<Element> _elements = root.getElements();
    final Iterable<ModelType> mts = Iterables.<ModelType>filter(_elements, ModelType.class);
    int _size = IterableExtensions.size(mts);
    monitor.beginTask("Generating interfaces", _size);
    this.cleanInterfaces(res, project, monitor);
    final Consumer<ModelType> _function = (ModelType mt) -> {
      boolean _isCanceled = monitor.isCanceled();
      if (_isCanceled) {
        throw new OperationCanceledException();
      }
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("platform:/resource/");
      String _name = project.getName();
      _builder.append(_name, "");
      _builder.append("/model-gen/");
      String _name_1 = mt.getName();
      _builder.append(_name_1, "");
      _builder.append(".ecore");
      final String ecoreUri = _builder.toString();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Registering new EPackage for ");
      String _name_2 = mt.getName();
      _builder_1.append(_name_2, "");
      _builder_1.append(" in EMF registry");
      MelangeBuilder.log.debug(_builder_1);
      List<EPackage> _pkgs = this._modelingElementExtensions.getPkgs(mt);
      EPackage _head_1 = IterableExtensions.<EPackage>head(_pkgs);
      String _nsURI = _head_1.getNsURI();
      boolean _containsKey = EPackage.Registry.INSTANCE.containsKey(_nsURI);
      boolean _not = (!_containsKey);
      if (_not) {
        List<EPackage> _pkgs_1 = this._modelingElementExtensions.getPkgs(mt);
        EPackage _head_2 = IterableExtensions.<EPackage>head(_pkgs_1);
        String _nsURI_1 = _head_2.getNsURI();
        List<EPackage> _pkgs_2 = this._modelingElementExtensions.getPkgs(mt);
        EPackage _head_3 = IterableExtensions.<EPackage>head(_pkgs_2);
        EPackage.Registry.INSTANCE.put(_nsURI_1, _head_3);
      }
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append("Serializing Ecore interface description for ");
      String _name_3 = mt.getName();
      _builder_2.append(_name_3, "");
      _builder_2.append(" in ");
      _builder_2.append(ecoreUri, "");
      MelangeBuilder.log.debug(_builder_2);
      String _uri = this._modelTypeExtensions.getUri(mt);
      this._modelingElementExtensions.createEcore(mt, ecoreUri, _uri);
      monitor.worked(1);
    };
    mts.forEach(_function);
  }
  
  public void generateLanguages(final Resource res, final IProject project, final IProgressMonitor monitor) {
    EList<EObject> _contents = res.getContents();
    EObject _head = IterableExtensions.<EObject>head(_contents);
    final ModelTypingSpace root = ((ModelTypingSpace) _head);
    EList<Element> _elements = root.getElements();
    Iterable<Language> _filter = Iterables.<Language>filter(_elements, Language.class);
    final Function1<Language, Boolean> _function = (Language it) -> {
      return Boolean.valueOf(this._languageExtensions.isGeneratedByMelange(it));
    };
    final Iterable<Language> toGenerate = IterableExtensions.<Language>filter(_filter, _function);
    int _size = IterableExtensions.size(toGenerate);
    monitor.beginTask("Generating EMF runtime for languages", _size);
    this.cleanLanguages(res, project, monitor);
    final Consumer<Language> _function_1 = (Language l) -> {
      boolean _isCanceled = monitor.isCanceled();
      if (_isCanceled) {
        throw new OperationCanceledException();
      }
      String _externalRuntimeName = this._languageExtensions.getExternalRuntimeName(l);
      this.eclipseHelper.createEMFRuntimeProject(_externalRuntimeName, l);
      this._languageExtensions.createExternalEcore(l);
      this._languageExtensions.createExternalGenmodel(l);
      Metamodel _syntax = l.getSyntax();
      List<GenModel> _genmodels = this._metamodelExtensions.getGenmodels(_syntax);
      GenModel _head_1 = IterableExtensions.<GenModel>head(_genmodels);
      this._ecoreExtensions.generateCode(_head_1);
      this._languageExtensions.createExternalAspects(l);
      String _externalRuntimeName_1 = this._languageExtensions.getExternalRuntimeName(l);
      this.eclipseHelper.addDependencies(project, Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_externalRuntimeName_1)));
      monitor.worked(1);
    };
    toGenerate.forEach(_function_1);
  }
  
  public void generateAdapters(final Resource res, final IProject project, final IProgressMonitor monitor) {
    EclipseResourceFileSystemAccess2 _get = this.fileSystemAccessProvider.get();
    final Procedure1<EclipseResourceFileSystemAccess2> _function = (EclipseResourceFileSystemAccess2 f) -> {
      f.setMonitor(monitor);
      f.setProject(project);
    };
    final EclipseResourceFileSystemAccess2 fsa = ObjectExtensions.<EclipseResourceFileSystemAccess2>operator_doubleArrow(_get, _function);
    Set<OutputConfiguration> _outputConfigurations = this.outputProvider.getOutputConfigurations();
    final Consumer<OutputConfiguration> _function_1 = (OutputConfiguration it) -> {
      Map<String, OutputConfiguration> _outputConfigurations_1 = fsa.getOutputConfigurations();
      String _name = it.getName();
      _outputConfigurations_1.put(_name, it);
    };
    _outputConfigurations.forEach(_function_1);
    this.cleanAdapters(res, project, monitor);
    this.generator.doGenerate(res, fsa);
  }
  
  public void generatePluginXml(final Resource res, final IProject project, final IProgressMonitor monitor) {
    EList<EObject> _contents = res.getContents();
    EObject _head = IterableExtensions.<EObject>head(_contents);
    final ModelTypingSpace root = ((ModelTypingSpace) _head);
    this.extensionProcessor.preProcess(root, false);
  }
  
  /**
   * - Clean the src-gen/ and model-gen/ folders of the current project
   * - For each language generated by Melange, delete its associated projects
   * - Remove the dangling dependencies from the current project
   */
  public void cleanAll(final Resource res, final IProject project, final IProgressMonitor monitor) {
    this.cleanAdapters(res, project, monitor);
    this.cleanInterfaces(res, project, monitor);
    this.cleanLanguages(res, project, monitor);
  }
  
  public void cleanLanguages(final Resource res, final IProject project, final IProgressMonitor monitor) {
    EList<EObject> _contents = res.getContents();
    EObject _head = IterableExtensions.<EObject>head(_contents);
    final ModelTypingSpace root = ((ModelTypingSpace) _head);
    final ArrayList<String> danglingBundles = CollectionLiterals.<String>newArrayList();
    EList<Element> _elements = root.getElements();
    Iterable<Language> _filter = Iterables.<Language>filter(_elements, Language.class);
    final Function1<Language, Boolean> _function = (Language it) -> {
      return Boolean.valueOf(this._languageExtensions.isGeneratedByMelange(it));
    };
    Iterable<Language> _filter_1 = IterableExtensions.<Language>filter(_filter, _function);
    final Consumer<Language> _function_1 = (Language l) -> {
      try {
        final String runtimeName = this._languageExtensions.getExternalRuntimeName(l);
        IWorkspace _workspace = project.getWorkspace();
        IWorkspaceRoot _root = _workspace.getRoot();
        final IProject runtimeProject = _root.getProject(runtimeName);
        runtimeProject.delete(true, true, monitor);
        danglingBundles.add(runtimeName);
      } catch (Throwable _e) {
        throw Exceptions.sneakyThrow(_e);
      }
    };
    _filter_1.forEach(_function_1);
    this.eclipseHelper.removeDependencies(project, danglingBundles);
  }
  
  public void cleanInterfaces(final Resource res, final IProject project, final IProgressMonitor monitor) {
    try {
      final IFolder modelGenFolder = project.getFolder("model-gen/");
      boolean _exists = modelGenFolder.exists();
      if (_exists) {
        IResource[] _members = modelGenFolder.members();
        final Consumer<IResource> _function = (IResource it) -> {
          try {
            it.delete(true, monitor);
          } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
          }
        };
        ((List<IResource>)Conversions.doWrapArray(_members)).forEach(_function);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void cleanAdapters(final Resource res, final IProject project, final IProgressMonitor monitor) {
    try {
      final IFolder srcGenFolder = project.getFolder("src-gen/");
      boolean _exists = srcGenFolder.exists();
      if (_exists) {
        IResource[] _members = srcGenFolder.members();
        final Consumer<IResource> _function = (IResource it) -> {
          try {
            it.delete(true, monitor);
          } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
          }
        };
        ((List<IResource>)Conversions.doWrapArray(_members)).forEach(_function);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private void waitForAutoBuild() {
    boolean wasInterrupted = false;
    do {
      try {
        IJobManager _jobManager = Job.getJobManager();
        _jobManager.join(ResourcesPlugin.FAMILY_AUTO_BUILD, null);
        wasInterrupted = false;
      } catch (final Throwable _t) {
        if (_t instanceof OperationCanceledException) {
          final OperationCanceledException e = (OperationCanceledException)_t;
          e.printStackTrace();
        } else if (_t instanceof InterruptedException) {
          final InterruptedException e_1 = (InterruptedException)_t;
          wasInterrupted = true;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    } while(wasInterrupted);
  }
}
