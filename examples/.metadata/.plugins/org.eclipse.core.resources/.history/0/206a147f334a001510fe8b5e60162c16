package rhapsody;

import fr.inria.diverse.k3.al.annotationprocessor.Aspect;
import java.util.ArrayList;
import java.util.Hashtable;
import org.eclipse.emf.common.util.EList;

/* @Aspect(className = /* name is null */) */@SuppressWarnings("all")
public class RegionAspect {
  public void initRegion(final Hashtable<String, Object> context) {
    throw new Error("Unresolved compilation problems:"
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nPseudostate cannot be resolved to a type."
      + "\nPseudostate cannot be resolved to a type."
      + "\nPseudostate cannot be resolved to a type."
      + "\nPseudostate cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field PseudostateKind is undefined for the type RegionAspect"
      + "\nThe method evalTransition is undefined for the type RegionAspect"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\ngetContextPathByRegion cannot be resolved"
      + "\nsubvertex cannot be resolved"
      + "\nfindFirst cannot be resolved"
      + "\nkind cannot be resolved"
      + "\n== cannot be resolved"
      + "\nINITIAL cannot be resolved"
      + "\noutgoing cannot be resolved"
      + "\ntarget cannot be resolved");
  }
  
  public String getContextPathByRegion() {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nname cannot be resolved");
  }
  
  /**
   * Performs a step in the state machine i.e., reads an entry of the input stack and executes it.
   * If there are several events in the same step they are executed sequentially.
   */
  public void step(final Hashtable<String, Object> context, final EList<String> events) {
    throw new Error("Unresolved compilation problems:"
      + "\nAbstractState cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nState cannot be resolved to a type."
      + "\nState cannot be resolved to a type."
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method evalTransition is undefined for the type RegionAspect"
      + "\nThe method alreadyFired is undefined for the type RegionAspect"
      + "\nThe method evalTransition is undefined for the type RegionAspect"
      + "\nThe method outgoing is undefined for the type RegionAspect"
      + "\nThe method resetFired is undefined for the type RegionAspect"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\ngetCurrentState cannot be resolved"
      + "\ngetActiveTransitions cannot be resolved"
      + "\nfindOldActiveStates cannot be resolved"
      + "\nfindNewActiveTransitions cannot be resolved"
      + "\nfindNewActiveStates cannot be resolved"
      + "\nexitState cannot be resolved"
      + "\nremoveStatesFromContext cannot be resolved"
      + "\naddStatesToContext cannot be resolved"
      + "\n! cannot be resolved"
      + "\nforEach cannot be resolved");
  }
  
  public void removeStatesFromContext(final Hashtable<String, Object> context, final /* ArrayList<AbstractState> */Object toRemove) {
    throw new Error("Unresolved compilation problems:"
      + "\nAbstractState cannot be resolved to a type."
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\ncontextPathByRegion cannot be resolved");
  }
  
  public void addStatesToContext(final Hashtable<String, Object> context, final /* ArrayList<AbstractState> */Object newStates) {
    throw new Error("Unresolved compilation problems:"
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\ncontextPathByRegion cannot be resolved"
      + "\ncontextPathByRegion cannot be resolved");
  }
  
  /**
   * Returns the current state of the machine. It corresponds to the current set of active states.
   */
  public /* ArrayList<AbstractState> */Object getCurrentState(final Hashtable<String, Object> context, final EList<String> events) {
    throw new Error("Unresolved compilation problems:"
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nAbstractState cannot be resolved to a type."
      + "\nThe method or field _self is undefined for the type RegionAspect"
      + "\nname cannot be resolved");
  }
  
  /**
   * Returns the active transitions of a vertex
   */
  public /* EList<Transition> */Object getActiveTransitions(final /* AbstractState */Object vertex, final EList<String> events) {
    throw new Error("Unresolved compilation problems:"
      + "\nTransition cannot be resolved to a type."
      + "\nTransition cannot be resolved to a type."
      + "\noutgoing cannot be resolved"
      + "\ntrigger cannot be resolved"
      + "\n== cannot be resolved"
      + "\n|| cannot be resolved"
      + "\ntrigger cannot be resolved"
      + "\n!= cannot be resolved"
      + "\n&& cannot be resolved"
      + "\ntrigger cannot be resolved"
      + "\nevalTrigger cannot be resolved");
  }
  
  /**
   * Finds the set of states that are active before the step and that will be left after the step.
   */
  public void findOldActiveStates(final /* ArrayList<AbstractState> */Object oldActiveStates, final /* Transition */Object selectedTransition, final Hashtable<String, Object> context) {
    throw new Error("Unresolved compilation problems:"
      + "\nsource cannot be resolved"
      + "\nsource cannot be resolved");
  }
  
  /**
   * Finds the set of states that will be active after the step.
   */
  public void findNewActiveStates(final /* ArrayList<AbstractState> */Object newActiveStates, final /* Transition */Object selectedTransition, final /* ArrayList<Transition> */Object currentActiveTransitions, final Hashtable<String, Object> context) {
    throw new Error("Unresolved compilation problems:"
      + "\ntarget cannot be resolved"
      + "\nalreadyFired cannot be resolved"
      + "\n! cannot be resolved"
      + "\ntarget cannot be resolved");
  }
  
  /**
   * Finds the transitions that will be fired during the step.
   */
  public void findNewActiveTransitions(final /* ArrayList<Transition> */Object newActiveTransitions, final /* Transition */Object selectedTransition, final Hashtable<String, Object> context) {
    newActiveTransitions.add(selectedTransition);
  }
}
